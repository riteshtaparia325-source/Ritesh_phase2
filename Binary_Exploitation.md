
# 1. buffer overflow 0

This challenge required to overflow a buffer amongst given code so as to print the flag.  

## Solution:

1.  My thought process was to first analyze the source code (`vuln.c`) to understand the program's logic and find the vulnerability.I noticed a custom signal handler for `SIGSEGV`. This told me the goal was not to avoid a crash, but to intentionally cause a Segmentation Fault(in buffer). The program is designed to catch this crash and give me the flag when I do.

2.  I looked for where a buffer overflow could happen. The `main` function reads input into `buf1`, which is 100 bytes long. This is safe. However, it then calls the `vuln` function with that input.The `vuln` function copies our input into `buf2`, which is only 16 bytes long. The `strcpy` function does not check the length and will keep copying bytes past the end of `buf2`, overflowing the stack.

3.  I just need to provide an input string that is longer than 16 bytes.This will overflow and write over other data on the stack.When the `vuln` function tries to `ret` (return), it will use the corrupted address, try to jump to an invalid memory location, and cause the Segmentation Fault.The signal handler will catch this, and the program will print the flag.

4.  To ensure as said in code, I first created a dummy flag.txt to dry run an check the stack overflow.
 
5.  I launched the challenge instance, which provided a `netcat` (nc) command. To send a long To send a long, non-printable string, I used a simple Python one-liner to "pipe" the payload to `netcat`. I chose a string of 30 'A's, which is well over the 16-byte limit
  
```
 nc saturn.picoctf.net 60983
Input: python -c 'print "A" * 30' | nc saturn.picoctf.net 60983
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
```
C++ code:
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```


###flag:
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}

## Concepts learnt:

I learnt the basic concept of stack overflow how and when it happens. How stacks are designed as temporary allocation of memomory and how internally computer functions during stack overflow.
  - Stack Buffer Overflow The core concept of writing more data to a buffer than it was allocated to hold.
  - Segmentation Fault (SIGSEGV): A program crash that occurs when it tries to access memory it doesn't have permission to.
  - Signal Handlers:A program's ability to "catch" system signals like `SIGSEGV` and run a custom function (`sigsegv_handler`) instead of just dying. This was the entire point of the challenge.

  - `gets()`: Extremely dangerous because it reads input without any size limit. It's what allowed us to create an input larger than 100 byte.
  - `strcpy()`:Dangerous because it copies a string until it sees a null byte, without checking if the destination buffer is large enough.
  
Also used Python `python -c` and Pipelining (`|`) to generate a specific payload (`"A" * 30`) and "pipe" it as the input to another program.

## Notes:

None
## Resources:

https://www.geeksforgeeks.org/cpp/signal-handling-in-cpp/
https://www.youtube.com/watch?v=T03idxny9jE&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=13
https://www.youtube.com/watch?v=CRTR5ljBjPM
-------------------------------------------------------------------

# 2. format string 0
In this challenge we had to again use stack overflow giving right inputs to obtain flag.

## Solution:

My thought process was to first analyze the source code to find the goal and the vulnerabilities.Just like the previous challenge, the program has a `sigsegv_handler` that prints the flag if the program crashes with a Segmentation Fault (SIGSEGV). Therefore, the goal is to cause a crash.

2.  The program operates in two stages. I first have to satisfy the `serve_patrick` function, which will then call the `serve_bob` function. The crash must happen in this second stage.

3.  Stage 1: Satisfy Patrick:
    * This function asks for a burger recommendation.
    * If the input is on the menu, the program runs `int count = printf(choice1);`.
    * To advance to `serve_bob`, this `count` (the number of characters printed) must be greater than `2 * BUFSIZE` (which is 2*32 = 64).
    * I inspected and in the choice `Gr%114d_Cheese` `%114d` format specifier tells `printf` to print a number (popped from the stack) and pad it with spaces to be 114 characters wide.
    * The total character count will be: `Gr` (2) + `114` (from the padding) + `_Cheese` (7) = 123 characters which is way greatwr than 64 to pass to bob.


4.  Stage 2: Crash for Bob (Get the Flag):
    * The `serve_bob` function gives a new menu and asks for a new choice.If the choice is valid, the program runs `printf(choice2);`.
    * My goal is to crash the program so I inspected Bob's menu and the choice `Cla%sic_Che%s%steak` contains the `%s` format specifier twice.
    * The `%s` specifier tells `printf` to pop a value from the stack, treat it as a memory address (a pointer), and print the string located at that address.
    * The program will pop some random data from the stack which is not a valid address for a string and when `printf` tries to read from this invalid address, the operating system will trigger a **Segmentation Fault (SIGSEGV)**.
    * The `sigsegv_handler` catches the crash and prints the flag.


    I connected with `netcat` and sent the two payloads in order.

    ```bash
    ritesh@LAPTOP-9AUNFI81:/mnt/c/Users/Asus/Downloads$ nc mimas.picoctf.net 55150
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_ef312157}
^Z
[4]+  Stopped                 nc mimas.picoctf.net 55150
ritesh@LAPTOP-9AUNFI81:/mnt/c/Users/Asus/Downloads$ 

    ```

## Flag: 
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_ef312157}

## Concepts learnt:

The critical vulnerability where user-controlled input is used as the format string for printf and learned that printf returns an int equal to the total number of characters printed. This was the mechanism for the check in `serve_patrick`.
  - `%114d`: to "inflate" the output of `printf` to pass a size check.
  - `%s`: specifier works by popping a pointer from the stack and reading from that address.
 
A bit more than previous challenge this challenge made me learn to cause crashing by printing a string from popping a pointer in stack which will not be found and hence cause error.
## Notes:

  - Initially got confused on how to cause crash since like last challenge was treing to increase the bit size to cause stack overflow unaware could have caused crash by different reasons as well
##References

 -  https://www.youtube.com/watch?v=0N8d7Yw-sN8
 - https://www.tutorialspoint.com/cprogramming/c_format_specifiers.htm


------------------------------------------------------------------


